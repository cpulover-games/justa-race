<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Justa Race</title>
</head>

<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        // fundamental
        /** @type {HTMLCanvasElement} */ // declare type in VSCode (for code completion)
        var canvas;
        /** @type {CanvasRenderingContext2D} */
        var canvasContext;
        const FPS = 30;
        const BG_COLOR = "black";
        const COLORS = ["green", "yellow", "red"]; // to randomize element color
        var indexColor = 0;

        // key codes
        const KEY_LEFT_ARROW = 37;
        const KEY_RIGHT_ARROW = 39;
        const KEY_UP_ARROW = 38;
        const KEY_DOWN_ARROW = 40;

        // mouse
        var mouseX;
        var mouseY;
        const TEXT_COLOR = "yellow";

        // car
        var carPic = document.createElement("img");
        var carPicLoaded = false;
        var carX;
        var carY;
        var carSpeed;
        var carAngle;
        const BALL_SIZE = 10;
        var carColor;
        // car control
        var keyHeldGas = false;
        var keyHeldReverse = false;
        var keyTurnLeft = false;
        var keyTurnRight = false;
        const CAR_FRICTION = 0.98;
        const CAR_DRIVE_POWER = 0.3; // gas power
        const CAR_REVERSE_POWER = 0.3; // go backward
        const CAR_TURN_RATE = 0.2; // turn left and right

        // track
        const TRACK_COLS = 20;
        const TRACK_ROWS = 15;
        var trackGrid = [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
            1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
            1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,
            1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1,
            1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
            1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            1, 0, 2, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
        ];
        const TRACK_ROAD = 0;
        const TRACK_WALL = 1;
        const TRACK_CAR = 2;
        const TRACK_WIDTH = 40;
        const TRACK_HEIGHT = 40;
        const TRACK_GAP = 2;
        var trackColor;

        // setup script
        window.onload = function () {
            canvas = document.getElementById("gameCanvas");
            canvasContext = canvas.getContext("2d");

            // load assets
            carPic.src = "player1car.png";
            carPic.onload = function () {
                carPicLoaded = true;
            }

            initGame();

            setInterval(updateAll, 1000 / FPS); // invoke updateAll() fps times/second

            // events
            canvas.addEventListener('mousemove', updateMousePos);
            document.addEventListener('keydown', keyPressed);
            document.addEventListener('keyup', keyReleased);
        }

        /* INITIALIZATION */
        function initGame() {
            initColors();
            initCar();
        }

        function initColors() {
            // indexColor=0;
            carColor = COLORS[indexColor];
            trackColor = COLORS[indexColor];
        }

        function initCar() {
            carSpeed = 0;
            carAngle = -Math.PI / 2;
            for (currentRow = 0; currentRow < TRACK_ROWS; currentRow++) {
                for (currentCol = 0; currentCol < TRACK_COLS; currentCol++) {
                    var indexArray = colRowToIndexArray(currentCol, currentRow);
                    if (trackGrid[indexArray] == TRACK_CAR) {
                        // convert to road to prevent car from stucking due to collision
                        // trackGrid[indexArray] = TRACK_ROAD; 

                        carX = currentCol * TRACK_WIDTH + TRACK_WIDTH / 2;
                        carY = currentRow * TRACK_HEIGHT + TRACK_HEIGHT / 2;
                    }
                }
            }
        }
        /* END OF INITIALIZATION */

        function updateAll() {
            moveAll();
            drawAll();
            trackCarCollision();
        }

        /* COLLISION */
        function trackCarCollision() {
            // indicate which col and row of trackGrid[] the car are in
            var carTrackCol = Math.floor(carX / TRACK_WIDTH);
            var carTrackRow = Math.floor(carY / TRACK_HEIGHT);
            // convert to index array with col and row
            var trackIndexUnderCar = colRowToIndexArray(carTrackCol, carTrackRow);

            // boundaries of col and row
            if (carTrackCol >= 0 && carTrackCol < TRACK_COLS &&
                carTrackRow >= 0 && carTrackRow < TRACK_ROWS &&
                trackGrid[trackIndexUnderCar] == TRACK_WALL) { // collision happens if wall available
                // first undo car's most recent motion so that its center no longer overlap the wall
                // which makes it stuck
                carX -= Math.cos(carAngle) * carSpeed;
                carY -= Math.sin(carAngle) * carSpeed;
                // then bound car with decreased speed
                carSpeed *= -0.5;
            }
        }
        /* END OF COLLISION */

        /* DRAWING */
        function drawAll() {
            // big frame (draw every time to clear screen)
            colorRect(0, 0, canvas.width, canvas.height, BG_COLOR);


            // tracks
            drawTracks();
            // car
            if (carPicLoaded) {
                drawBitmapCenteredWithRotation(carPic, carX, carY, carAngle);
            }
            // mouse position
            colorText(mouseX + ", " + mouseY, mouseX, mouseY, TEXT_COLOR);
        }

        /* EVENTS */
        function updateMousePos(event) {
            //???
            var rect = canvas.getBoundingClientRect();
            var root = document.documentElement;

            mouseX = event.clientX - rect.left - root.scrollLeft;
            mouseY = event.clientY - rect.top - root.scrollTop;
            // cheat();
        }

        function keyPressed(event) {
            event.preventDefault();
            if (event.keyCode == KEY_UP_ARROW) {
                keyHeldGas = true;
            } else if (event.keyCode == KEY_DOWN_ARROW) {
                keyHeldReverse = true;
            } else if (event.keyCode == KEY_LEFT_ARROW) {
                keyTurnLeft = true;
            } else if (event.keyCode == KEY_RIGHT_ARROW) {
                keyTurnRight = true;
            }
        }

        function keyReleased(event) {
            event.preventDefault();
            if (event.keyCode == KEY_UP_ARROW) {
                keyHeldGas = false;
            } else if (event.keyCode == KEY_DOWN_ARROW) {
                keyHeldReverse = false;
            } else if (event.keyCode == KEY_LEFT_ARROW) {
                keyTurnLeft = false;
            } else if (event.keyCode == KEY_RIGHT_ARROW) {
                keyTurnRight = false;
            }
        }

        function cheat() {
            // cheat for testing: make car follow the mouse
            carX = mouseX;
            carY = mouseY;
            carSpeed = 4;
        }
        /* END OF EVENTS */

        /* DRAWING HELPERS */
        function colorRect(topX, topY, boxWidth, boxHeight, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillRect(topX, topY, boxWidth, boxHeight);
        }

        function colorCircle(centerX, centerY, radius, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.beginPath();
            canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            canvasContext.fill();
        }

        function colorText(text, textX, textY, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillText(text, textX, textY);
        }

        function drawTracks() {
            for (currentRow = 0; currentRow < TRACK_ROWS; currentRow++) {
                for (currentCol = 0; currentCol < TRACK_COLS; currentCol++) {
                    var indexArray = colRowToIndexArray(currentCol, currentRow);
                    if (trackGrid[indexArray] == 1) {
                        colorRect(TRACK_WIDTH * currentCol, TRACK_HEIGHT * currentRow, TRACK_WIDTH - TRACK_GAP,
                            TRACK_HEIGHT -
                            TRACK_GAP, trackColor);
                    }
                }
            }
        }

        function drawBitmapCenteredWithRotation(bitmap, atX, atY,
            angle) { // graphical operations excute by reversed order
            // 1: sets us up so we can forget these operations
            canvasContext.save();
            // 4: slide its center to atX, atY
            canvasContext.translate(atX, atY);
            // 3: rotate center around center (radian)
            canvasContext.rotate(angle);
            // 2: draw image at center
            canvasContext.drawImage(bitmap, -bitmap.width / 2, -bitmap.height / 2);
            // 5: forget everything since save
            canvasContext.restore();
        }

        // convert to index of trackGrid[] when know its col and row
        function colRowToIndexArray(col, row) {
            return col + row * TRACK_COLS;
        }
        /* END OF DRAWING HELPERS */

        /* MOTION */
        function moveAll() {
            // car
            carSpeed *= CAR_FRICTION;
            if (keyHeldGas) {
                carSpeed += CAR_DRIVE_POWER;
            }
            if (keyHeldReverse) {
                carSpeed -= CAR_REVERSE_POWER;
            }
            if (keyTurnLeft) {
                carAngle -= CAR_TURN_RATE;
            }
            if (keyTurnRight) {
                carAngle += CAR_TURN_RATE;
            }
            carX += Math.cos(carAngle) * carSpeed;
            carY += Math.sin(carAngle) * carSpeed;
        }
    </script>
</body>

</html>